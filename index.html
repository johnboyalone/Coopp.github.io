<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Co-op Puzzle Adventure</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
    <!-- Phaser.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <script>
        // Global variables for Firebase access
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- Start NetworkManager Class ---
        class NetworkManager {
            constructor() {
                this.app = null;
                this.database = null;
                this.auth = null;
                this.gameRef = null;
                this.gameData = null;
                this.onGameDataUpdated = null;
                this.currentUserId = null;
            }

            async init(callback) {
                if (!firebase.apps.length) {
                    this.app = firebase.initializeApp(firebaseConfig);
                } else {
                    this.app = firebase.app();
                }
                
                this.auth = firebase.auth();
                this.database = firebase.database();

                try {
                    if (initialAuthToken) {
                        await this.auth.signInWithCustomToken(initialAuthToken);
                    } else {
                        await this.auth.signInAnonymously();
                    }
                } catch (error) {
                    console.error("Firebase Auth Error:", error);
                }

                this.auth.onAuthStateChanged(user => {
                    if (user) {
                        this.currentUserId = user.uid;
                        callback(); // Callback to start the game after auth is ready
                    } else {
                        this.currentUserId = null;
                    }
                });
            }

            // Creates a new game room and sets initial state.
            async createNewGame(playerType) {
                const gameId = this.generateGameId();
                this.gameRef = this.database.ref(`artifacts/${appId}/public/data/games/${gameId}`);
                const initialPuzzleId = Math.floor(Math.random() * 3); // Random puzzle theme

                const initialData = {
                    players: {
                        [this.currentUserId]: {
                            type: playerType,
                            status: 'online',
                            puzzleId: initialPuzzleId,
                        }
                    },
                    puzzleState: {
                        // Example puzzle state for demonstration
                        // Player A sees the code, Player B sees the safe
                        playerA_code: Math.floor(1000 + Math.random() * 9000).toString(),
                        playerB_safe_open: false,
                        // And vice versa
                        playerB_symbol_code: ['circle', 'triangle', 'square'][Math.floor(Math.random() * 3)],
                        playerA_hint_found: false
                    },
                    timer: 300, // 5 minutes in seconds
                    startTime: firebase.database.ServerValue.TIMESTAMP,
                    status: 'waiting',
                    lastUpdated: firebase.database.ServerValue.TIMESTAMP,
                };

                await this.gameRef.set(initialData);
                return gameId;
            }

            // Joins an existing game room.
            async joinGame(gameId, playerType) {
                this.gameRef = this.database.ref(`artifacts/${appId}/public/data/games/${gameId}`);
                const snapshot = await this.gameRef.get();
                if (!snapshot.exists()) {
                    throw new Error('Game room not found.');
                }

                const gameData = snapshot.val();
                if (Object.keys(gameData.players).length >= 2) {
                    throw new Error('Game room is full.');
                }

                const updates = {};
                updates[`players/${this.currentUserId}`] = {
                    type: playerType,
                    status: 'online',
                    puzzleId: Object.values(gameData.players)[0].puzzleId // Sync puzzle theme
                };
                updates.status = 'playing';
                updates.lastUpdated = firebase.database.ServerValue.TIMESTAMP;
                
                await this.gameRef.update(updates);
            }

            // Sets up a real-time listener for game data changes.
            listenForGameData(callback) {
                if (this.gameRef) {
                    this.onGameDataUpdated = callback;
                    this.gameRef.on('value', snapshot => {
                        this.gameData = snapshot.val();
                        if (this.onGameDataUpdated) {
                            this.onGameDataUpdated(this.gameData);
                        }
                    });
                }
            }

            // Updates a specific part of the game state.
            updateGameState(path, value) {
                if (this.gameRef) {
                    const updates = {};
                    updates[path] = value;
                    updates.lastUpdated = firebase.database.ServerValue.TIMESTAMP;
                    this.gameRef.update(updates);
                }
            }
            
            // Generates a simple, unique game ID.
            generateGameId() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let result = '';
                for (let i = 0; i < 6; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }
        }
        // --- End NetworkManager Class ---

        // --- Start Game Logic ---
        const networkManager = new NetworkManager();
        let phaserGame;
        let playerType = null;
        let gameId = null;

        // Phaser game config
        const config = {
            type: Phaser.AUTO,
            scale: {
                mode: Phaser.Scale.FIT,
                parent: 'game-container',
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: 720,
                height: 1280, // Designed for portrait mobile
            },
            scene: {
                preload: preload,
                create: create,
                update: update,
            }
        };

        let gameScene;
        let timerText;
        let puzzleText;
        let hintObject;
        let puzzleObjects = {};

        // Puzzle data and assets
        const puzzles = [
            { name: '‡∏ö‡πâ‡∏≤‡∏ô‡∏ú‡∏µ‡∏™‡∏¥‡∏á', id: 0, playerA_asset: 'safe', playerB_asset: 'code_pad' },
            { name: '‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏•‡∏±‡∏ö', id: 1, playerA_asset: 'vials', playerB_asset: 'diagram' },
            { name: '‡∏õ‡∏£‡∏≤‡∏™‡∏≤‡∏ó‡πÄ‡∏ß‡∏ó‡∏°‡∏ô‡∏ï‡∏£‡πå', id: 2, playerA_asset: 'runes', playerB_asset: 'magical_door' }
        ];

        // Preload assets for all puzzles
        function preload() {
            this.load.image('background_haunted', 'https://placehold.co/720x1280/1a1a1a/ffffff?text=Haunted+House');
            this.load.image('background_lab', 'https://placehold.co/720x1280/333344/ffffff?text=Secret+Lab');
            this.load.image('background_castle', 'https://placehold.co/720x1280/4a3a6b/ffffff?text=Magic+Castle');

            // General assets
            this.load.image('safe', 'https://placehold.co/200x200/555555/ffffff?text=SAFE');
            this.load.image('code_pad', 'https://placehold.co/200x200/999999/000000?text=CODE+PAD');
            this.load.image('vials', 'https://placehold.co/200x200/80ff80/000000?text=Vials');
            this.load.image('diagram', 'https://placehold.co/200x200/4444ff/ffffff?text=Diagram');
            this.load.image('runes', 'https://placehold.co/200x200/c080ff/ffffff?text=Runes');
            this.load.image('magical_door', 'https://placehold.co/200x200/a0a0ff/ffffff?text=Door');
            this.load.image('lock_icon', 'https://placehold.co/50x50/ff0000/ffffff?text=üîí');
            this.load.image('unlock_icon', 'https://placehold.co/50x50/00ff00/ffffff?text=üîì');
        }

        function create() {
            gameScene = this;

            // Wait for network to be ready before starting the game
            networkManager.init(() => {
                // Create UI for selecting player type and joining/creating games
                createUI();
            });
        }

        function createUI() {
            // Clear any previous UI
            gameScene.children.removeAll();

            const titleText = gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height * 0.2, '‡πÄ‡∏Å‡∏°‡πÑ‡∏Ç‡∏õ‡∏£‡∏¥‡∏®‡∏ô‡∏≤ Co-op', { fontSize: '48px', color: '#fff', align: 'center' }).setOrigin(0.5);

            const playerAButton = gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height * 0.4, '‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏´‡πâ‡∏≠‡∏á A', { fontSize: '32px', color: '#fff', backgroundColor: '#336699', padding: { x: 20, y: 10 } })
                .setOrigin(0.5)
                .setInteractive()
                .on('pointerdown', () => startGame('A'));

            const playerBButton = gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height * 0.55, '‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏´‡πâ‡∏≠‡∏á B', { fontSize: '32px', color: '#fff', backgroundColor: '#993366', padding: { x: 20, y: 10 } })
                .setOrigin(0.5)
                .setInteractive()
                .on('pointerdown', () => startGame('B'));
            
            const gameIdInput = gameScene.add.dom(gameScene.scale.width / 2, gameScene.scale.height * 0.75).createFromHTML('<input type="text" placeholder="‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)" style="width: 250px; font-size: 24px; text-align: center; padding: 10px; border-radius: 10px;">');
            
            const joinButton = gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height * 0.85, '‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏´‡πâ‡∏≠‡∏á', { fontSize: '32px', color: '#fff', backgroundColor: '#666666', padding: { x: 20, y: 10 } })
                .setOrigin(0.5)
                .setInteractive()
                .on('pointerdown', async () => {
                    const inputVal = gameIdInput.node.value;
                    if (inputVal) {
                        try {
                            await networkManager.joinGame(inputVal.toUpperCase(), 'B'); // Assumes joiner is always B for simplicity
                            gameId = inputVal.toUpperCase();
                            setupGameScene();
                        } catch (e) {
                            gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height * 0.95, e.message, { fontSize: '20px', color: '#ff0000' }).setOrigin(0.5);
                        }
                    } else {
                         gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height * 0.95, '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á', { fontSize: '20px', color: '#ff0000' }).setOrigin(0.5);
                    }
                });
        }

        async function startGame(type) {
            playerType = type;
            gameId = await networkManager.createNewGame(playerType);
            setupGameScene();
        }

        function setupGameScene() {
            gameScene.children.removeAll();

            // Display Game ID
            gameScene.add.text(gameScene.scale.width / 2, 50, `‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á: ${gameId}`, { fontSize: '32px', color: '#fff' }).setOrigin(0.5);

            // Initial background based on puzzle theme
            const puzzleId = networkManager.gameData.players[networkManager.currentUserId].puzzleId;
            const puzzleTheme = puzzles.find(p => p.id === puzzleId);
            gameScene.add.image(gameScene.scale.width / 2, gameScene.scale.height / 2, `background_${puzzleTheme.name.toLowerCase().replace(/ /g, '_')}`).setOrigin(0.5);

            // Initial timer display
            timerText = gameScene.add.text(gameScene.scale.width / 2, 120, '‡πÄ‡∏ß‡∏•‡∏≤: 05:00', { fontSize: '48px', color: '#fff' }).setOrigin(0.5);
            
            // UI for puzzles
            createPuzzles(puzzleTheme);

            // Listen for state changes
            networkManager.listenForGameData(handleGameDataUpdate);
        }

        function createPuzzles(puzzleTheme) {
            // Player A's puzzle setup
            if (playerType === 'A') {
                const puzzleAsset = puzzleTheme.playerA_asset;
                puzzleObjects.main = gameScene.add.image(gameScene.scale.width / 2, gameScene.scale.height / 2, puzzleAsset)
                    .setInteractive()
                    .on('pointerdown', () => {
                        const code = networkManager.gameData.puzzleState.playerA_code;
                        puzzleText = gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height / 2, `‡∏£‡∏´‡∏±‡∏™‡∏Ñ‡∏∑‡∏≠: ${code}`, { fontSize: '40px', color: '#ff0000' }).setOrigin(0.5);
                    });
                    
                hintObject = gameScene.add.image(gameScene.scale.width / 2, gameScene.scale.height * 0.75, 'lock_icon')
                    .setScale(0.5)
                    .setInteractive()
                    .on('pointerdown', () => {
                        networkManager.updateGameState('puzzleState/playerA_hint_found', true);
                    });

            // Player B's puzzle setup
            } else if (playerType === 'B') {
                const puzzleAsset = puzzleTheme.playerB_asset;
                puzzleObjects.main = gameScene.add.image(gameScene.scale.width / 2, gameScene.scale.height / 2, puzzleAsset)
                    .setInteractive()
                    .on('pointerdown', () => {
                        const enteredCode = prompt('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏£‡∏´‡∏±‡∏™‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏Å Player A:');
                        if (enteredCode && enteredCode === networkManager.gameData.puzzleState.playerA_code) {
                            networkManager.updateGameState('puzzleState/playerB_safe_open', true);
                            gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height * 0.8, '‡∏ï‡∏π‡πâ‡∏ô‡∏¥‡∏£‡∏†‡∏±‡∏¢‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß!', { fontSize: '32px', color: '#00ff00' }).setOrigin(0.5);
                        } else {
                             gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height * 0.8, '‡∏£‡∏´‡∏±‡∏™‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á!', { fontSize: '32px', color: '#ff0000' }).setOrigin(0.5);
                        }
                    });

                hintObject = gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height * 0.75, '‡∏£‡∏≠‡∏Ñ‡∏≥‡πÉ‡∏ö‡πâ‡∏à‡∏≤‡∏Å Player A...', { fontSize: '28px', color: '#fff' }).setOrigin(0.5);
            }
        }

        function handleGameDataUpdate(data) {
            if (!data) return;

            // Update timer
            const timeElapsed = (Date.now() - data.startTime) / 1000;
            const timeLeft = Math.max(0, data.timer - timeElapsed);
            const minutes = Math.floor(timeLeft / 60);
            const seconds = Math.floor(timeLeft % 60);
            timerText.setText(`‡πÄ‡∏ß‡∏•‡∏≤: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`);

            // Game over condition
            if (timeLeft <= 0) {
                showGameOver(false);
                return;
            }

            // Check for puzzle completion
            if (data.puzzleState.playerA_hint_found && data.puzzleState.playerB_safe_open) {
                showGameOver(true);
            }

            // Update UI based on partner's actions
            if (playerType === 'B' && data.puzzleState.playerA_hint_found) {
                hintObject.setText('Player A ‡πÑ‡∏î‡πâ‡∏û‡∏ö‡∏Ñ‡∏≥‡πÉ‡∏ö‡πâ‡πÅ‡∏•‡πâ‡∏ß!');
            }
            
            if (playerType === 'A' && data.puzzleState.playerB_safe_open) {
                // Change the hint object to show it's completed
                hintObject.setTexture('unlock_icon');
                // A simple text to confirm completion
                gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height * 0.85, '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏ï‡∏π‡πâ‡∏ô‡∏¥‡∏£‡∏†‡∏±‡∏¢‡∏ñ‡∏π‡∏Å‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß!', { fontSize: '32px', color: '#00ff00' }).setOrigin(0.5);
            }
        }

        function update(time, delta) {
            // Game loop, primarily for a timer
        }

        function showGameOver(isWin) {
            gameScene.children.removeAll();
            let message = isWin ? '‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏î‡πâ‡∏ß‡∏¢! ‡πÑ‡∏Ç‡∏õ‡∏£‡∏¥‡∏®‡∏ô‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!' : '‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤! ‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏û‡πâ!';
            let color = isWin ? '#00ff00' : '#ff0000';
            const score = isWin ? Math.floor(100 + (networkManager.gameData.timer - ((Date.now() - networkManager.gameData.startTime) / 1000))) : 0;

            gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height * 0.4, message, { fontSize: '48px', color: color }).setOrigin(0.5);
            gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height * 0.5, `‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏™‡∏≤‡∏¢‡πÉ‡∏¢‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì: ${score}`, { fontSize: '36px', color: '#fff' }).setOrigin(0.5);
            
            const restartButton = gameScene.add.text(gameScene.scale.width / 2, gameScene.scale.height * 0.7, '‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà', { fontSize: '32px', color: '#fff', backgroundColor: '#666666', padding: { x: 20, y: 10 } })
                .setOrigin(0.5)
                .setInteractive()
                .on('pointerdown', () => {
                    phaserGame.destroy(true);
                    phaserGame = new Phaser.Game(config);
                });
        }

        // Initialize the game when the window loads
        window.onload = function () {
            phaserGame = new Phaser.Game(config);
        };
        // --- End Game Logic ---
    </script>
</body>
</html>
